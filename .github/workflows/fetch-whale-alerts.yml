name: Fetch Whale Alerts

on:
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes
  workflow_dispatch:  # Manual trigger

permissions:
  contents: write

jobs:
  fetch:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch Whale Alerts from Telegram
        run: |
          node << 'EOF'
          const https = require('https');
          const fs = require('fs');

          const TELEGRAM_URL = 'https://t.me/s/whale_alert_io';

          function fetchPage(url) {
            return new Promise((resolve, reject) => {
              https.get(url, {
                headers: {
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
              }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', reject);
              }).on('error', reject);
            });
          }

          function parseMessages(html) {
            const alerts = [];

            // Split by message blocks
            const blocks = html.split('tgme_widget_message_wrap');

            for (const block of blocks) {
              // Extract text content (removing HTML tags)
              const textMatch = block.match(/tgme_widget_message_text[^>]*>([\s\S]*?)<\/div>/);
              if (!textMatch) continue;

              // Clean HTML tags and get plain text
              const rawText = textMatch[1]
                .replace(/<a[^>]*>#([^<]+)<\/a>/g, '#$1')  // Keep hashtags
                .replace(/<br\/?>/g, ' ')
                .replace(/<[^>]+>/g, '')
                .replace(/\s+/g, ' ')
                .trim();

              // Extract datetime
              const timeMatch = block.match(/datetime="([^"]+)"/);
              if (!timeMatch) continue;
              const timestamp = Date.parse(timeMatch[1]);

              // Parse: "43,066,770 #XLM (7,142,667 USD) transferred from #Kraken to unknown wallet"
              const mainMatch = rawText.match(/([\d,]+(?:\.\d+)?)\s*#([A-Z]{2,10})\s*\(([\d,]+(?:\.\d+)?)\s*USD\)/i);
              if (!mainMatch) continue;

              const amount = parseFloat(mainMatch[1].replace(/,/g, ''));
              const symbol = mainMatch[2].toUpperCase();
              const amountUsd = parseFloat(mainMatch[3].replace(/,/g, ''));

              // Only $1M+ transactions
              if (amountUsd < 1000000) continue;

              // Determine blockchain
              let blockchain = 'unknown';
              if (['BTC', 'WBTC'].includes(symbol)) blockchain = 'bitcoin';
              else if (['ETH', 'WETH', 'stETH'].includes(symbol)) blockchain = 'ethereum';
              else if (['USDT', 'USDC', 'DAI', 'BUSD'].includes(symbol)) blockchain = 'stablecoin';
              else if (symbol === 'SOL') blockchain = 'solana';
              else if (symbol === 'XRP') blockchain = 'ripple';
              else if (symbol === 'XLM') blockchain = 'stellar';
              else if (symbol === 'TRX') blockchain = 'tron';
              else if (symbol === 'BNB') blockchain = 'binance';
              else if (symbol === 'DOGE') blockchain = 'dogecoin';
              else if (symbol === 'ADA') blockchain = 'cardano';

              // Parse from/to
              let fromOwner = 'unknown';
              let toOwner = 'unknown';
              let fromType = 'unknown';
              let toType = 'unknown';

              // "from #Kraken to unknown wallet" or "from unknown wallet to #Binance"
              const fromMatch = rawText.match(/from\s+#?(\w+)/i);
              const toMatch = rawText.match(/to\s+#?(\w+)/i);

              if (fromMatch) fromOwner = fromMatch[1];
              if (toMatch) toOwner = toMatch[1];

              // Detect exchanges
              const exchanges = ['binance', 'coinbase', 'kraken', 'bitfinex', 'huobi', 'okx', 'okex', 'bybit', 'kucoin', 'gemini', 'bitstamp', 'cryptocom', 'gateio', 'bitget', 'mexc', 'upbit', 'bithumb'];
              if (exchanges.some(e => fromOwner.toLowerCase().includes(e))) fromType = 'exchange';
              if (exchanges.some(e => toOwner.toLowerCase().includes(e))) toType = 'exchange';

              // Significance
              let significance = 'high';
              if (amountUsd >= 500000000) significance = 'extreme';
              else if (amountUsd >= 100000000) significance = 'very_high';

              alerts.push({
                id: `whale-${timestamp}-${symbol}-${Math.random().toString(36).substr(2, 6)}`,
                timestamp,
                blockchain,
                symbol,
                amount,
                amountUsd,
                from: { address: '', owner: fromOwner, ownerType: fromType },
                to: { address: '', owner: toOwner, ownerType: toType },
                transactionType: 'transfer',
                hash: '',
                significance
              });
            }

            return alerts;
          }

          async function main() {
            try {
              console.log('Fetching Telegram channel...');
              const html = await fetchPage(TELEGRAM_URL);
              console.log(`Got ${html.length} bytes`);

              const alerts = parseMessages(html);
              console.log(`Parsed ${alerts.length} alerts from page`);

              // Sort by timestamp descending
              alerts.sort((a, b) => b.timestamp - a.timestamp);

              // Load existing alerts
              let existingAlerts = [];
              try {
                const existing = fs.readFileSync('alerts.json', 'utf8');
                existingAlerts = JSON.parse(existing).alerts || [];
                console.log(`Loaded ${existingAlerts.length} existing alerts`);
              } catch (e) {
                console.log('No existing alerts file');
              }

              // Merge, keeping unique by timestamp+symbol+amount
              const seen = new Set();
              const allAlerts = [...alerts, ...existingAlerts];
              const finalAlerts = allAlerts.filter(a => {
                const key = `${a.timestamp}-${a.symbol}-${a.amountUsd}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
              }).slice(0, 200);

              const output = {
                lastUpdated: new Date().toISOString(),
                count: finalAlerts.length,
                minValueUsd: 1000000,
                alerts: finalAlerts
              };

              fs.writeFileSync('alerts.json', JSON.stringify(output, null, 2));
              console.log(`Saved ${finalAlerts.length} whale alerts`);

            } catch (error) {
              console.error('Error:', error.message);
              console.error(error.stack);
              process.exit(1);
            }
          }

          main();
          EOF

      - name: Commit and Push
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add alerts.json
          git diff --staged --quiet || git commit -m "Update whale alerts $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          git push
